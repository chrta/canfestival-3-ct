<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>CanFestival: /home/epimerde/documents/tc11/CanFestival-3/drivers/can_uvccm_win32/can_uvccm_win32.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>/home/epimerde/documents/tc11/CanFestival-3/drivers/can_uvccm_win32/can_uvccm_win32.cpp</h1><a href="can__uvccm__win32_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// can_uvccm_win32 adapter (http://www.gridconnect.com)</span>
<a name="l00002"></a>00002 <span class="comment">// driver for CanFestival-3 Win32 port</span>
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2007 Leonid Tochinski, ChattenAssociates, Inc.</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#if 0  // change to 1 if you use boost</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/algorithm/string/case_conv.hpp&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#else</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#endif</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span>
<a name="l00014"></a>00014 <span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<a name="l00015"></a>00015 <span class="preprocessor">#include "<a class="code" href="can__driver_8h.html">can_driver.h</a>"</span>
<a name="l00016"></a>00016 }
<a name="l00017"></a><a class="code" href="classcan__uvccm__win32.html">00017</a> <span class="keyword">class </span><a class="code" href="classcan__uvccm__win32.html">can_uvccm_win32</a>
<a name="l00018"></a>00018    {
<a name="l00019"></a>00019    <span class="keyword">public</span>:
<a name="l00020"></a><a class="code" href="classcan__uvccm__win32_1_1error.html">00020</a>       <span class="keyword">class </span><a class="code" href="classcan__uvccm__win32_1_1error.html">error</a>
<a name="l00021"></a>00021         {
<a name="l00022"></a>00022         };
<a name="l00023"></a>00023       <a class="code" href="classcan__uvccm__win32.html#f4f6d1f25174fd3b7d897a5f73bc363e">can_uvccm_win32</a>(<a class="code" href="structstruct__s__BOARD.html">s_BOARD</a> *board);
<a name="l00024"></a>00024       <a class="code" href="classcan__uvccm__win32.html#39bb5c7bb141391d0f2f34b7dd5f487c">~can_uvccm_win32</a>();
<a name="l00025"></a>00025       <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#3358bfa32c0164bc11d220745e3e0430">send</a>(<span class="keyword">const</span> <a class="code" href="structMessage.html">Message</a> *m);
<a name="l00026"></a>00026       <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#4301393c1d3046b35d0b545e761b94db">receive</a>(<a class="code" href="structMessage.html">Message</a> *m);
<a name="l00027"></a>00027    <span class="keyword">private</span>:
<a name="l00028"></a>00028       <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#7fb6732edc691451bc1d3206c07d4715">open_rs232</a>(<span class="keywordtype">int</span> port = 1, <span class="keywordtype">int</span> baud_rate = 57600);
<a name="l00029"></a>00029       <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#06f9d2fb860a821436471c3233f91dff">close_rs232</a>();
<a name="l00030"></a>00030       <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#c3d1d02a46518b2639beb6060f79f2a2">get_can_data</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* can_cmd_buf, <span class="keywordtype">long</span>&amp; bufsize, <a class="code" href="structMessage.html">Message</a>* m);
<a name="l00031"></a>00031       <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#0f2aed9c45f29e6082f37ea17aea46ae">set_can_data</a>(<span class="keyword">const</span> <a class="code" href="structMessage.html">Message</a>&amp; m, std::string&amp; can_cmd);
<a name="l00032"></a>00032    <span class="keyword">private</span>:
<a name="l00033"></a><a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">00033</a>       HANDLE <a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>;
<a name="l00034"></a><a class="code" href="classcan__uvccm__win32.html#cf25e6725871137696ab41b06fa05417">00034</a>       HANDLE <a class="code" href="classcan__uvccm__win32.html#cf25e6725871137696ab41b06fa05417">m_read_event</a>;
<a name="l00035"></a><a class="code" href="classcan__uvccm__win32.html#544ea7fd0e8a5d7cfb7cf9058d6020a4">00035</a>       HANDLE <a class="code" href="classcan__uvccm__win32.html#544ea7fd0e8a5d7cfb7cf9058d6020a4">m_write_event</a>;
<a name="l00036"></a><a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">00036</a>       std::string <a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>;
<a name="l00037"></a>00037    };
<a name="l00038"></a>00038 
<a name="l00039"></a><a class="code" href="classcan__uvccm__win32.html#f4f6d1f25174fd3b7d897a5f73bc363e">00039</a> <a class="code" href="classcan__uvccm__win32.html#f4f6d1f25174fd3b7d897a5f73bc363e">can_uvccm_win32::can_uvccm_win32</a>(<a class="code" href="structstruct__s__BOARD.html">s_BOARD</a> *board) : m_port(INVALID_HANDLE_VALUE),
<a name="l00040"></a>00040       m_read_event(0),
<a name="l00041"></a>00041       m_write_event(0)
<a name="l00042"></a>00042    {
<a name="l00043"></a>00043    <span class="keywordflow">if</span> (strcmp( board-&gt;<a class="code" href="structstruct__s__BOARD.html#5316679ded23cf846c63c06ab51a4646">baudrate</a>, <span class="stringliteral">"125K"</span>) || !<a class="code" href="classcan__uvccm__win32.html#7fb6732edc691451bc1d3206c07d4715">open_rs232</a>(1))
<a name="l00044"></a>00044       <span class="keywordflow">throw</span> <a class="code" href="classcan__uvccm__win32_1_1error.html">error</a>();
<a name="l00045"></a>00045    }
<a name="l00046"></a>00046 
<a name="l00047"></a><a class="code" href="classcan__uvccm__win32.html#39bb5c7bb141391d0f2f34b7dd5f487c">00047</a> <a class="code" href="classcan__uvccm__win32.html#39bb5c7bb141391d0f2f34b7dd5f487c">can_uvccm_win32::~can_uvccm_win32</a>()
<a name="l00048"></a>00048    {
<a name="l00049"></a>00049    <a class="code" href="classcan__uvccm__win32.html#06f9d2fb860a821436471c3233f91dff">close_rs232</a>();
<a name="l00050"></a>00050    }
<a name="l00051"></a>00051 
<a name="l00052"></a><a class="code" href="classcan__uvccm__win32.html#3358bfa32c0164bc11d220745e3e0430">00052</a> <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#3358bfa32c0164bc11d220745e3e0430">can_uvccm_win32::send</a>(<span class="keyword">const</span> <a class="code" href="structMessage.html">Message</a> *m)
<a name="l00053"></a>00053    {
<a name="l00054"></a>00054    <span class="keywordflow">if</span> (<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a> == INVALID_HANDLE_VALUE)
<a name="l00055"></a>00055       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00056"></a>00056 
<a name="l00057"></a>00057    <span class="comment">// build can_uvccm_win32 command string</span>
<a name="l00058"></a>00058    std::string can_cmd;
<a name="l00059"></a>00059    <a class="code" href="classcan__uvccm__win32.html#0f2aed9c45f29e6082f37ea17aea46ae">set_can_data</a>(*m, can_cmd);
<a name="l00060"></a>00060 
<a name="l00061"></a>00061    OVERLAPPED overlapped;
<a name="l00062"></a>00062    ::memset(&amp;overlapped, 0, <span class="keyword">sizeof</span> overlapped);
<a name="l00063"></a>00063    overlapped.hEvent = <a class="code" href="classcan__uvccm__win32.html#544ea7fd0e8a5d7cfb7cf9058d6020a4">m_write_event</a>;
<a name="l00064"></a>00064    ::ResetEvent(overlapped.hEvent);
<a name="l00065"></a>00065 
<a name="l00066"></a>00066    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bytes_written = 0;<a class="code" href="namespaceeds__utils.html#d9540832adbe476f1ba6a0cafcbbafbc"></a>
<a name="l00067"></a>00067 <a class="code" href="namespaceeds__utils.html#d9540832adbe476f1ba6a0cafcbbafbc">   ::WriteFile</a>(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, can_cmd.c_str(), (<span class="keywordtype">unsigned</span> long)can_cmd.size(), &amp;bytes_written, &amp;overlapped);
<a name="l00068"></a>00068    <span class="comment">// wait for write operation completion</span>
<a name="l00069"></a>00069    <span class="keyword">enum</span> { WRITE_TIMEOUT = 1000 };
<a name="l00070"></a>00070    ::WaitForSingleObject(overlapped.hEvent, WRITE_TIMEOUT);
<a name="l00071"></a>00071    <span class="comment">// get number of bytes written</span>
<a name="l00072"></a>00072    ::GetOverlappedResult(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, &amp;overlapped, &amp;bytes_written, <a class="code" href="def_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00073"></a>00073 
<a name="l00074"></a>00074    <span class="keywordtype">bool</span> result = (bytes_written == can_cmd.size());
<a name="l00075"></a>00075 
<a name="l00076"></a>00076    <span class="keywordflow">return</span> result;
<a name="l00077"></a>00077    }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 
<a name="l00080"></a><a class="code" href="classcan__uvccm__win32.html#4301393c1d3046b35d0b545e761b94db">00080</a> <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#4301393c1d3046b35d0b545e761b94db">can_uvccm_win32::receive</a>(<a class="code" href="structMessage.html">Message</a> *m)
<a name="l00081"></a>00081    {
<a name="l00082"></a>00082    <span class="keywordflow">if</span> (<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a> == INVALID_HANDLE_VALUE)
<a name="l00083"></a>00083       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085    <span class="keywordtype">long</span> res_buffer_size = (long)<a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.size();
<a name="l00086"></a>00086    <span class="keywordtype">bool</span> result = <a class="code" href="classcan__uvccm__win32.html#c3d1d02a46518b2639beb6060f79f2a2">get_can_data</a>(<a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.c_str(), res_buffer_size, m);
<a name="l00087"></a>00087    <span class="keywordflow">if</span> (result)
<a name="l00088"></a>00088       {
<a name="l00089"></a>00089       <a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.erase(0, res_buffer_size);
<a name="l00090"></a>00090       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00091"></a>00091       }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093    <span class="keyword">enum</span> { READ_TIMEOUT = 500 };
<a name="l00094"></a>00094 
<a name="l00095"></a>00095    OVERLAPPED overlapped;
<a name="l00096"></a>00096    ::memset(&amp;overlapped, 0, <span class="keyword">sizeof</span> overlapped);
<a name="l00097"></a>00097    overlapped.hEvent = <a class="code" href="classcan__uvccm__win32.html#cf25e6725871137696ab41b06fa05417">m_read_event</a>;
<a name="l00098"></a>00098    ::ResetEvent(overlapped.hEvent);
<a name="l00099"></a>00099    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> event_mask = 0;
<a name="l00100"></a>00100 
<a name="l00101"></a>00101    <span class="keywordflow">if</span> (<a class="code" href="def_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a> == ::WaitCommEvent(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, &amp;event_mask, &amp;overlapped) &amp;&amp; ERROR_IO_PENDING == ::GetLastError())
<a name="l00102"></a>00102       {
<a name="l00103"></a>00103       <span class="keywordflow">if</span> (WAIT_TIMEOUT == ::WaitForSingleObject(overlapped.hEvent, READ_TIMEOUT))
<a name="l00104"></a>00104          <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00105"></a>00105       }
<a name="l00106"></a>00106 
<a name="l00107"></a>00107    <span class="comment">// get number of bytes in the input que</span>
<a name="l00108"></a>00108    COMSTAT stat;
<a name="l00109"></a>00109    ::memset(&amp;stat, 0, <span class="keyword">sizeof</span> stat);
<a name="l00110"></a>00110    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> errors = 0;
<a name="l00111"></a>00111    ::ClearCommError(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, &amp;errors, &amp;stat);
<a name="l00112"></a>00112    <span class="keywordflow">if</span> (stat.cbInQue == 0)
<a name="l00113"></a>00113       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114    <span class="keywordtype">char</span> buffer[3000];
<a name="l00115"></a>00115 
<a name="l00116"></a>00116    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bytes_to_read = min(stat.cbInQue, sizeof (buffer));
<a name="l00117"></a>00117 
<a name="l00118"></a>00118    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bytes_read = 0;
<a name="l00119"></a>00119    ::ReadFile(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, buffer, bytes_to_read, &amp;bytes_read, &amp;overlapped);
<a name="l00120"></a>00120    <span class="comment">// wait for read operation completion</span>
<a name="l00121"></a>00121    ::WaitForSingleObject(overlapped.hEvent, READ_TIMEOUT);
<a name="l00122"></a>00122    <span class="comment">// get number of bytes read</span>
<a name="l00123"></a>00123    ::GetOverlappedResult(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, &amp;overlapped, &amp;bytes_read, <a class="code" href="def_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00124"></a>00124    result = <span class="keyword">false</span>;
<a name="l00125"></a>00125    <span class="keywordflow">if</span> (bytes_read &gt; 0)
<a name="l00126"></a>00126       {
<a name="l00127"></a>00127       <a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.append(buffer, bytes_read);
<a name="l00128"></a>00128       res_buffer_size = (long)<a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.size();
<a name="l00129"></a>00129       result = <a class="code" href="classcan__uvccm__win32.html#c3d1d02a46518b2639beb6060f79f2a2">get_can_data</a>(<a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.c_str(), res_buffer_size, m);
<a name="l00130"></a>00130       <span class="keywordflow">if</span> (result)
<a name="l00131"></a>00131          <a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.erase(0, res_buffer_size);
<a name="l00132"></a>00132       }
<a name="l00133"></a>00133    <span class="keywordflow">return</span> result;
<a name="l00134"></a>00134    }
<a name="l00135"></a>00135 
<a name="l00136"></a><a class="code" href="classcan__uvccm__win32.html#7fb6732edc691451bc1d3206c07d4715">00136</a> <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#7fb6732edc691451bc1d3206c07d4715">can_uvccm_win32::open_rs232</a>(<span class="keywordtype">int</span> port, <span class="keywordtype">int</span> baud_rate)
<a name="l00137"></a>00137    {
<a name="l00138"></a>00138    <span class="keywordflow">if</span> (<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a> != INVALID_HANDLE_VALUE)
<a name="l00139"></a>00139       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141    std::ostringstream device_name;
<a name="l00142"></a>00142    device_name &lt;&lt; <span class="stringliteral">"COM"</span> &lt;&lt; port;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144    <a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a> = ::CreateFile(device_name.str().c_str(),
<a name="l00145"></a>00145                          GENERIC_READ | GENERIC_WRITE,
<a name="l00146"></a>00146                          0,   <span class="comment">// exclusive access</span>
<a name="l00147"></a>00147                          NULL,   <span class="comment">// no security</span>
<a name="l00148"></a>00148                          OPEN_EXISTING,
<a name="l00149"></a>00149                          FILE_FLAG_OVERLAPPED,   <span class="comment">// overlapped I/O</span>
<a name="l00150"></a>00150                          NULL); <span class="comment">// null template</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152    <span class="comment">// Check the returned handle for INVALID_HANDLE_VALUE and then set the buffer sizes.</span>
<a name="l00153"></a>00153    <span class="keywordflow">if</span> (<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a> == INVALID_HANDLE_VALUE)
<a name="l00154"></a>00154       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156    <span class="comment">//  SetCommMask(m_hCom,EV_RXCHAR|EV_TXEMPTY|EV_CTS|EV_DSR|EV_RLSD|EV_BREAK|EV_ERR|EV_RING); //</span>
<a name="l00157"></a>00157    ::SetCommMask(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, EV_RXFLAG);
<a name="l00158"></a>00158 
<a name="l00159"></a>00159    COMMTIMEOUTS timeouts;
<a name="l00160"></a>00160    ::memset(&amp;timeouts, 0, <span class="keyword">sizeof</span> (timeouts));
<a name="l00161"></a>00161    timeouts.ReadIntervalTimeout = -1;
<a name="l00162"></a>00162    timeouts.ReadTotalTimeoutConstant = 0;
<a name="l00163"></a>00163    timeouts.ReadTotalTimeoutMultiplier = 0;
<a name="l00164"></a>00164    timeouts.WriteTotalTimeoutConstant = 5000;
<a name="l00165"></a>00165    timeouts.WriteTotalTimeoutMultiplier = 0;
<a name="l00166"></a>00166    SetCommTimeouts(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, &amp;timeouts); <span class="comment">//</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168    ::SetupComm(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, 1024, 512); <span class="comment">// set buffer sizes</span>
<a name="l00169"></a>00169 
<a name="l00170"></a>00170    <span class="comment">// Port settings are specified in a Data Communication Block (DCB). The easiest way to initialize a DCB is to call GetCommState to fill in its default values, override the values that you want to change and then call SetCommState to set the values.</span>
<a name="l00171"></a>00171    DCB dcb;
<a name="l00172"></a>00172    ::memset(&amp;dcb, 0, <span class="keyword">sizeof</span> (dcb));
<a name="l00173"></a>00173    ::GetCommState(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, &amp;dcb);
<a name="l00174"></a>00174    dcb.BaudRate = baud_rate;
<a name="l00175"></a>00175    dcb.ByteSize = 8;
<a name="l00176"></a>00176    dcb.Parity = NOPARITY;
<a name="l00177"></a>00177    dcb.StopBits = ONESTOPBIT;
<a name="l00178"></a>00178    dcb.fAbortOnError = <a class="code" href="def_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00179"></a>00179    dcb.EvtChar = 0x0A; <span class="comment">// '\n' character</span>
<a name="l00180"></a>00180    ::SetCommState(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, &amp;dcb);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182    ::PurgeComm(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, PURGE_RXABORT | PURGE_RXCLEAR | PURGE_TXABORT | PURGE_TXCLEAR);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184    <a class="code" href="classcan__uvccm__win32.html#cf25e6725871137696ab41b06fa05417">m_read_event</a> = ::CreateEvent(NULL, <a class="code" href="def_8h.html#a8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>, <a class="code" href="def_8h.html#a93f0eb578d23995850d61f7d61c55c1">FALSE</a>, NULL);
<a name="l00185"></a>00185    <a class="code" href="classcan__uvccm__win32.html#544ea7fd0e8a5d7cfb7cf9058d6020a4">m_write_event</a> = ::CreateEvent(NULL, TRUE, FALSE, NULL);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00188"></a>00188    }
<a name="l00189"></a>00189 
<a name="l00190"></a><a class="code" href="classcan__uvccm__win32.html#06f9d2fb860a821436471c3233f91dff">00190</a> <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#06f9d2fb860a821436471c3233f91dff">can_uvccm_win32::close_rs232</a>()
<a name="l00191"></a>00191    {
<a name="l00192"></a>00192    <span class="keywordflow">if</span> (<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a> != INVALID_HANDLE_VALUE)
<a name="l00193"></a>00193       {
<a name="l00194"></a>00194       ::PurgeComm(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>, PURGE_RXABORT | PURGE_RXCLEAR | PURGE_TXABORT | PURGE_TXCLEAR);
<a name="l00195"></a>00195       ::CloseHandle(<a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a>);
<a name="l00196"></a>00196       <a class="code" href="classcan__uvccm__win32.html#3f13c1748b3cd57fd1d478782428859a">m_port</a> = INVALID_HANDLE_VALUE;
<a name="l00197"></a>00197       ::CloseHandle(<a class="code" href="classcan__uvccm__win32.html#cf25e6725871137696ab41b06fa05417">m_read_event</a>);
<a name="l00198"></a>00198       <a class="code" href="classcan__uvccm__win32.html#cf25e6725871137696ab41b06fa05417">m_read_event</a> = 0;
<a name="l00199"></a>00199       ::CloseHandle(<a class="code" href="classcan__uvccm__win32.html#544ea7fd0e8a5d7cfb7cf9058d6020a4">m_write_event</a>);
<a name="l00200"></a>00200       <a class="code" href="classcan__uvccm__win32.html#544ea7fd0e8a5d7cfb7cf9058d6020a4">m_write_event</a> = 0;
<a name="l00201"></a>00201       <a class="code" href="classcan__uvccm__win32.html#d264855657adc02fbc687f37d302fc9f">m_residual_buffer</a>.clear();
<a name="l00202"></a>00202       }
<a name="l00203"></a>00203    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00204"></a>00204    }
<a name="l00205"></a>00205 
<a name="l00206"></a><a class="code" href="classcan__uvccm__win32.html#c3d1d02a46518b2639beb6060f79f2a2">00206</a> <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#c3d1d02a46518b2639beb6060f79f2a2">can_uvccm_win32::get_can_data</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* can_cmd_buf, <span class="keywordtype">long</span>&amp; bufsize, <a class="code" href="structMessage.html">Message</a>* m)
<a name="l00207"></a>00207    {
<a name="l00208"></a>00208    <span class="keywordflow">if</span> (bufsize &lt; 5)
<a name="l00209"></a>00209       {
<a name="l00210"></a>00210       bufsize = 0;
<a name="l00211"></a>00211       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00212"></a>00212       }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214    <a class="code" href="structMessage.html">Message</a> msg;
<a name="l00215"></a>00215    ::memset(&amp;msg, 0 , <span class="keyword">sizeof</span> (msg));
<a name="l00216"></a>00216    <span class="keywordtype">char</span> colon = 0, type = 0, request = 0;
<a name="l00217"></a>00217    std::istringstream buf(std::string(can_cmd_buf, bufsize));
<a name="l00218"></a>00218    buf &gt;&gt; colon &gt;&gt; type &gt;&gt; std::hex &gt;&gt; msg.<a class="code" href="structMessage.html#c5d40bde75d015beb48293c052a218b5">cob_id</a>.<a class="code" href="structSHORT__CAN.html#614e1c6a40f1261e2b15ad69b19e9698">w</a> &gt;&gt; request;
<a name="l00219"></a>00219    <span class="keywordflow">if</span> (colon != <span class="charliteral">':'</span> || (type != <span class="charliteral">'S'</span> &amp;&amp; type != <span class="charliteral">'X'</span>))
<a name="l00220"></a>00220       {
<a name="l00221"></a>00221       bufsize = 0;
<a name="l00222"></a>00222       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00223"></a>00223       }
<a name="l00224"></a>00224    <span class="keywordflow">if</span> (request == <span class="charliteral">'N'</span>)
<a name="l00225"></a>00225       {
<a name="l00226"></a>00226       msg.<a class="code" href="structMessage.html#41c5a4e7eaeb2c2ae1af2b2c83129615">rtr</a> = 0;
<a name="l00227"></a>00227       <span class="keywordflow">for</span> (msg.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a> = 0; msg.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a> &lt; 8; ++msg.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a>)
<a name="l00228"></a>00228          {
<a name="l00229"></a>00229          std::string data_byte_str;
<a name="l00230"></a>00230          buf &gt;&gt; std::setw(2) &gt;&gt; data_byte_str;
<a name="l00231"></a>00231          <span class="keywordflow">if</span> (data_byte_str[0] == <span class="charliteral">';'</span>)
<a name="l00232"></a>00232             <span class="keywordflow">break</span>;
<a name="l00233"></a>00233          <span class="keywordtype">long</span> byte_val = -1;
<a name="l00234"></a>00234          std::istringstream(data_byte_str) &gt;&gt; std::hex &gt;&gt; byte_val;
<a name="l00235"></a>00235          <span class="keywordflow">if</span> (byte_val == -1)
<a name="l00236"></a>00236             {
<a name="l00237"></a>00237             bufsize = 0;
<a name="l00238"></a>00238             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00239"></a>00239             }
<a name="l00240"></a>00240          msg.<a class="code" href="structMessage.html#229865b09691e658677ba76f2d82ce89">data</a>[msg.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a>] = (<a class="code" href="hcs12_2applicfg_8h.html#539234687760592d01a8b0d3357bc00e">UNS8</a>)byte_val;
<a name="l00241"></a>00241          }
<a name="l00242"></a>00242       <span class="keywordflow">if</span> (msg.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a> == 8)
<a name="l00243"></a>00243          {
<a name="l00244"></a>00244          <span class="keywordtype">char</span> semicolon = 0;
<a name="l00245"></a>00245          buf &gt;&gt; semicolon;
<a name="l00246"></a>00246          <span class="keywordflow">if</span> (semicolon != <span class="charliteral">';'</span>)
<a name="l00247"></a>00247             {
<a name="l00248"></a>00248             bufsize = 0;
<a name="l00249"></a>00249             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00250"></a>00250             }
<a name="l00251"></a>00251          }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253       }
<a name="l00254"></a>00254    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (request == <span class="charliteral">'R'</span>)
<a name="l00255"></a>00255       {
<a name="l00256"></a>00256       msg.<a class="code" href="structMessage.html#41c5a4e7eaeb2c2ae1af2b2c83129615">rtr</a> = 1;
<a name="l00257"></a>00257       buf &gt;&gt; msg.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a>;
<a name="l00258"></a>00258       }
<a name="l00259"></a>00259    <span class="keywordflow">else</span>
<a name="l00260"></a>00260       {
<a name="l00261"></a>00261       bufsize = 0;
<a name="l00262"></a>00262       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00263"></a>00263       }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265    bufsize = buf.tellg();
<a name="l00266"></a>00266 
<a name="l00267"></a>00267    *m = msg;
<a name="l00268"></a>00268    <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00269"></a>00269    }
<a name="l00270"></a>00270 
<a name="l00271"></a><a class="code" href="classcan__uvccm__win32.html#0f2aed9c45f29e6082f37ea17aea46ae">00271</a> <span class="keywordtype">bool</span> <a class="code" href="classcan__uvccm__win32.html#0f2aed9c45f29e6082f37ea17aea46ae">can_uvccm_win32::set_can_data</a>(<span class="keyword">const</span> <a class="code" href="structMessage.html">Message</a>&amp; m, std::string&amp; can_cmd)
<a name="l00272"></a>00272    {
<a name="l00273"></a>00273    <span class="comment">// build can_uvccm_win32 command string</span>
<a name="l00274"></a>00274    std::ostringstream can_cmd_str;
<a name="l00275"></a>00275    can_cmd_str &lt;&lt; <span class="stringliteral">":S"</span> &lt;&lt; std::hex &lt;&lt; m.<a class="code" href="structMessage.html#c5d40bde75d015beb48293c052a218b5">cob_id</a>.<a class="code" href="structSHORT__CAN.html#614e1c6a40f1261e2b15ad69b19e9698">w</a>;
<a name="l00276"></a>00276    <span class="keywordflow">if</span> (m.<a class="code" href="structMessage.html#41c5a4e7eaeb2c2ae1af2b2c83129615">rtr</a> == 1)
<a name="l00277"></a>00277       {
<a name="l00278"></a>00278       can_cmd_str &lt;&lt; <span class="charliteral">'R'</span> &lt;&lt; (long)m.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a>;
<a name="l00279"></a>00279       }
<a name="l00280"></a>00280    <span class="keywordflow">else</span>
<a name="l00281"></a>00281       {
<a name="l00282"></a>00282       can_cmd_str &lt;&lt; <span class="charliteral">'N'</span>;
<a name="l00283"></a>00283       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m.<a class="code" href="structMessage.html#d1dd9a88dda088ff4c7073d49613613d">len</a>; ++i)
<a name="l00284"></a>00284          can_cmd_str &lt;&lt; std::hex &lt;&lt; std::setfill(<span class="charliteral">'0'</span>) &lt;&lt; std::setw(2) &lt;&lt; (<span class="keywordtype">long</span>)m.<a class="code" href="structMessage.html#229865b09691e658677ba76f2d82ce89">data</a>[i];
<a name="l00285"></a>00285       }
<a name="l00286"></a>00286    can_cmd_str &lt;&lt; <span class="charliteral">';'</span>;
<a name="l00287"></a>00287    can_cmd = can_cmd_str.str();
<a name="l00288"></a>00288 <span class="preprocessor">#ifdef BOOST_VERSION</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span>   boost::to_upper(can_cmd);
<a name="l00290"></a>00290 <span class="preprocessor">#else</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>   std::transform(can_cmd.begin(),can_cmd.end(),can_cmd.begin(),::toupper);
<a name="l00292"></a>00292 <span class="preprocessor">#endif</span>
<a name="l00293"></a>00293 <span class="preprocessor"></span>   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00294"></a>00294    }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 
<a name="l00297"></a>00297 <span class="comment">//------------------------------------------------------------------------</span>
<a name="l00298"></a>00298 <span class="keyword">extern</span> <span class="stringliteral">"C"</span>
<a name="l00299"></a><a class="code" href="can__uvccm__win32_8cpp.html#6b3248e95acf2b08d1fd8b42610cc5a6">00299</a>    <a class="code" href="hcs12_2applicfg_8h.html#539234687760592d01a8b0d3357bc00e">UNS8</a> <a class="code" href="can__lincan_8c.html#6b3248e95acf2b08d1fd8b42610cc5a6">canReceive_driver</a>(<a class="code" href="unix_2applicfg_8h.html#712c7b28987b12b8d400df19c92d0f5e">CAN_HANDLE</a> fd0, <a class="code" href="structMessage.html">Message</a> *m)
<a name="l00300"></a>00300    {
<a name="l00301"></a>00301    <span class="keywordflow">return</span> (<a class="code" href="hcs12_2applicfg_8h.html#539234687760592d01a8b0d3357bc00e">UNS8</a>)(!(reinterpret_cast&lt;can_uvccm_win32*&gt;(fd0)-&gt;receive(m)));
<a name="l00302"></a>00302    }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="keyword">extern</span> <span class="stringliteral">"C"</span>
<a name="l00305"></a><a class="code" href="can__uvccm__win32_8cpp.html#def95aee49efa13dd047d0b3b5507ad3">00305</a>    <a class="code" href="hcs12_2applicfg_8h.html#539234687760592d01a8b0d3357bc00e">UNS8</a> <a class="code" href="can__lincan_8c.html#def95aee49efa13dd047d0b3b5507ad3">canSend_driver</a>(<a class="code" href="unix_2applicfg_8h.html#712c7b28987b12b8d400df19c92d0f5e">CAN_HANDLE</a> fd0, <a class="code" href="structMessage.html">Message</a> *m)
<a name="l00306"></a>00306    {
<a name="l00307"></a>00307    <span class="keywordflow">return</span> (<a class="code" href="hcs12_2applicfg_8h.html#539234687760592d01a8b0d3357bc00e">UNS8</a>)reinterpret_cast&lt;can_uvccm_win32*&gt;(fd0)-&gt;send(m);
<a name="l00308"></a>00308    }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 <span class="keyword">extern</span> <span class="stringliteral">"C"</span>
<a name="l00311"></a><a class="code" href="can__uvccm__win32_8cpp.html#945403aba7f36acbd2e7160ade361bab">00311</a>    <a class="code" href="unix_2applicfg_8h.html#712c7b28987b12b8d400df19c92d0f5e">CAN_HANDLE</a> <a class="code" href="can__lincan_8c.html#945403aba7f36acbd2e7160ade361bab">canOpen_driver</a>(<a class="code" href="structstruct__s__BOARD.html">s_BOARD</a> *board)
<a name="l00312"></a>00312    {
<a name="l00313"></a>00313    <span class="keywordflow">try</span>
<a name="l00314"></a>00314       {
<a name="l00315"></a>00315       <span class="keywordflow">return</span> (<a class="code" href="unix_2applicfg_8h.html#712c7b28987b12b8d400df19c92d0f5e">CAN_HANDLE</a>) <span class="keyword">new</span> <a class="code" href="classcan__uvccm__win32.html">can_uvccm_win32</a>(board);
<a name="l00316"></a>00316       }
<a name="l00317"></a>00317    <span class="keywordflow">catch</span> (<a class="code" href="classcan__uvccm__win32_1_1error.html">can_uvccm_win32::error</a>&amp;)
<a name="l00318"></a>00318       {
<a name="l00319"></a>00319       <span class="keywordflow">return</span> NULL;
<a name="l00320"></a>00320       }
<a name="l00321"></a>00321    }
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 <span class="keyword">extern</span> <span class="stringliteral">"C"</span>
<a name="l00324"></a><a class="code" href="can__uvccm__win32_8cpp.html#f0856b6c70c571ef7aa4509abf18db6d">00324</a>    <span class="keywordtype">int</span> <a class="code" href="can__lincan_8c.html#76e6a915d0e40a23b863198b2aaa5545">canClose_driver</a>(<a class="code" href="unix_2applicfg_8h.html#712c7b28987b12b8d400df19c92d0f5e">CAN_HANDLE</a> inst)
<a name="l00325"></a>00325    {
<a name="l00326"></a>00326    <span class="keyword">delete</span> reinterpret_cast&lt;can_uvccm_win32*&gt;(inst);
<a name="l00327"></a>00327    <span class="keywordflow">return</span> 1;
<a name="l00328"></a>00328    }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330 
<a name="l00331"></a>00331    
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Mon Jun 4 16:29:06 2007 for CanFestival by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
